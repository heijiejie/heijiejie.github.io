<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>heijiejie的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>heijiejie的博客小站</description>
    <pubDate>Thu, 19 Apr 2018 13:49:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LayaAir组件学习笔记</title>
      <link>http://yoursite.com/2018/04/19/LayaAir%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://yoursite.com/2018/04/19/LayaAir%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 19 Apr 2018 13:45:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;###LayaAir组件学习笔记&lt;/p&gt;
&lt;p&gt;编辑默认的组件资源对应规则(不区分大小写)&lt;/p&gt;
&lt;p&gt;(1)Label组件(文本框)：label_xxx。&lt;/p&gt;
&lt;p&gt;(2)TextInput组件(输入框)：input_xxx或textinput_xxx&lt;/p&gt;
&lt;p&gt;(3)TextArea组件(文本域，带滚动条):area_xxx或textarea_xxx&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>###LayaAir组件学习笔记</p><p>编辑默认的组件资源对应规则(不区分大小写)</p><p>(1)Label组件(文本框)：label_xxx。</p><p>(2)TextInput组件(输入框)：input_xxx或textinput_xxx</p><p>(3)TextArea组件(文本域，带滚动条):area_xxx或textarea_xxx</p><a id="more"></a><p>(4)Button组件(按钮)：btn_xxx或button_xxx</p><p>(5)CheckBox组件(多选框)：check_xxx或checkbox_xxx</p><p>(6)Radio组件(单选框)：radio或radio_xxx</p><p>(7)Tab组件(标签组)：tab_xxx</p><p>(8)RadioGroup组件(单选框按钮组)：radiogroup_xxx</p><p>(9)VSlider组件(垂直滑动条)：vslider_xxx</p><p>(10)HSlider组件(水平滑动条)：hslider_xxx</p><p>(11)Clip组件(位图切片)：clip_xxx</p><p>(12)ProgressBar组件(进度条)：progress_xxx或progressbar_xxx</p><p>(13)ComboBox组件(下拉框)：combo_xxx或combobox_xxx</p><p>(14)VScrollBar组件(垂直滚动条)：vscroll_xxx 或vscrollbar_xxx</p><p>(15)HScrollBar组件(水平滚动条)：hscroll_xxx或hscrollbar_xxx</p><p>(16)Image组件(图形组件)：不是以上规则的，都会被识别为image组件</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/19/LayaAir%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LayaAir屏幕适配</title>
      <link>http://yoursite.com/2018/04/11/LayaAir%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</link>
      <guid>http://yoursite.com/2018/04/11/LayaAir%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</guid>
      <pubDate>Tue, 10 Apr 2018 17:28:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;LayaAir屏幕适配&lt;/p&gt;
&lt;p&gt;官方教程链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//ldc.layabox.com/index.php%3Fm%3Dcontent%26c%3Dindex%26a%3Dshow%26catid%3D8%26id%3D23&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LayaAir实战开发11-屏幕适配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;屏幕适配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着移动端设备(手机、平板、电视)的增多，设备碎片化、屏幕碎片化的程度也在不断增加，而我们今天要探讨的，则是对游戏显示影响比较大的屏幕碎片化。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>LayaAir屏幕适配</p><p>官方教程链接：<a href="https://link.zhihu.com/?target=http%3A//ldc.layabox.com/index.php%3Fm%3Dcontent%26c%3Dindex%26a%3Dshow%26catid%3D8%26id%3D23" target="_blank" rel="noopener">LayaAir实战开发11-屏幕适配</a></p><p><strong>屏幕适配</strong></p><p>随着移动端设备(手机、平板、电视)的增多，设备碎片化、屏幕碎片化的程度也在不断增加，而我们今天要探讨的，则是对游戏显示影响比较大的屏幕碎片化。</p><a id="more"></a><p>为了更深入的了解屏幕适配，我们先从Iphone屏幕分辨率发展说起：</p><p>在早先的移动设备中，屏幕像素都比较低，如 Iphone3，它的分辨率为320<em>480，在Iphone3上，一个像素等于一个屏幕物理像素。后来随着设备屏幕像素密度越来越高，从iphone4开始，苹果推出了Retina屏，分辨率变成了640</em>960，提高一倍，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这提高的就是devicePixelRatio，其他安卓移动设备也类似与此。</p><p>所以我们得出一个公式： 物理分辨率=像素分辨率*devicePixelRatio;</p><p>引擎对上述两种分辨率做了封装。</p><p>设备像素分辨率:Laya.Browser.clientWidth，Laya.Browser.clientHeight;</p><p>设备物理分辨率：Laya.Browser.width，Laya.Browser.height;</p><p>像素比：Laya.Browser.pixelRatio;</p><p>默认从浏览器获得的clientWidth不是像素分辨率，而是经过缩放过的分辨率，想要获得正确的分辨率，需要在html页面内设置viewport meta标签，设置content的值为”width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no”。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name='viewport' <span class="built_in">content</span>='<span class="built_in">width</span>=device-<span class="built_in">width</span>,</span><br><span class="line">initial-<span class="built_in">scale</span>=<span class="number">1.0</span>,minimum-<span class="built_in">scale</span>=<span class="number">1.0</span>,</span><br><span class="line">maximum-<span class="built_in">scale</span>=<span class="number">1.0</span>,user-scalable=no'/&gt;</span><br></pre></td></tr></table></figure><p>在LayaAir引擎内，如果页面未设置过viewport标签，则引擎会自动生成一个，以确保获取的正确宽高。</p><p><strong>适配模式</strong></p><p>LayaAir提供了多种适配模式供使用者选择，可以通过scaleMode属性进行设置，scaleMode有如下可选值：</p><p>noscale：应用保持设计宽高不变，不缩放不变形，stage的宽高等于设计宽高。</p><p>exactfit：应用根据屏幕大小铺满全屏，非等比缩放会变形，stage的宽高等于设计宽高。</p><p>showall：应用显示全部内容，按照最小比率缩放，等比缩放不变形，一边可能会留空白，stage的宽高等于设计宽高。</p><p>noborder：应用按照最大比率缩放显示，宽或高方向会显示一部分，等比缩放不变性，stage的宽高等于设计宽高。</p><p>full：应用保持设计宽高不变，不缩放不变形，stage的宽高等于屏幕宽高。</p><p>fixedwidth：应用保持设计宽度不变，高度根据屏幕比缩放，stage的宽度等于设计宽度，高度根据屏幕比率大小而变化。</p><p>fixedheight：应用保持设计高度不变，宽度根据屏幕比缩放，stage的高度等于设计宽度，宽度根据屏幕比率大小而变化。</p><p>比较常用的缩放模式有，showall，full，fixedwidth，fixedheight，具体用哪种适配模式，需要大家自己来衡量。</p><p><strong>对齐模式</strong></p><p>不仅可以设置非全屏缩放模式，比如noscale，showall，则还可以使用对齐模式进行对齐。</p><p>alignH：水平对齐方式，有”left”，”center”，”right”三种值可选。</p><p>alignV：垂直对齐方式，有”top”，”middle”，”bottom”三种值可选。</p><p><strong>横竖屏设置</strong></p><p>通过screenMode属性，可以设置游戏的横竖屏，在手机浏览器发生旋转后，还能正确的显示，有以下值可以选择。</p><p>“none” ：不更改屏幕。</p><p>“horizontal” ：自动横屏。</p><p>“vertical” ：自动竖屏。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/11/LayaAir%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript环境搭建</title>
      <link>http://yoursite.com/2018/04/10/TypeScript%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <guid>http://yoursite.com/2018/04/10/TypeScript%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <pubDate>Tue, 10 Apr 2018 10:49:50 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;阅读目录**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[环境搭建]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[第一部分、简介]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[第二部分、环境准备]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[第三部分、使用Visual Studio Code进行开发]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[其他相关内容]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<ul><li><p>阅读目录**</p><ul><li><p>[环境搭建]</p></li><li><p>[第一部分、简介]</p></li><li><p>[第二部分、环境准备]</p></li><li><p>[第三部分、使用Visual Studio Code进行开发]</p></li><li><p>[其他相关内容]</p></li></ul><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="[环境搭建]"></a>[环境搭建]</h1><blockquote><p>本篇将简单介绍一下TypeScript，并记录开发环境的搭建、使用Visual Studio Code进行一个简单的Demo开发过程。</p></blockquote><h1 id="第一部分、简介"><a href="#第一部分、简介" class="headerlink" title="第一部分、简介"></a>第一部分、简介</h1><p>TypeScript是一种由微软开发的自由和开源的编程语言。是JavaScript的一个超集。它在保留JavaScript语言本身特性的基础上添加了大量静态语言具有的一些特性，包括但不限于以下几点：</p><ul><li><ul><li><p>可选的静态类型</p></li><li><p>枚举、接口和类</p></li><li><p>命名空间</p></li><li><p>模块</p></li><li><p>Lambda表达式</p></li><li><p>编译时类型检查</p></li></ul></li></ul><p>在2013年6月微软正式发布了0.9版。之后在不断更新的过程中逐渐支持ECMAScript 2015（ES6）标准。</p><p>通过利用静态语言的特性和新标准，使JavaScript开发变得越来越简单。同时也很好的符合当前前端开发的模块化、工程化的开发方式和潮流。</p><h1 id="第二部分、环境准备"><a href="#第二部分、环境准备" class="headerlink" title="第二部分、环境准备"></a>第二部分、环境准备</h1><h3 id="一、安装Node-js"><a href="#一、安装Node-js" class="headerlink" title="一、安装Node.js"></a>一、安装Node.js</h3><p>安装文件下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js Downloads</a>。TypeScript源码需要进行编译以后才能运行，Node.js提供了编译环境。</p><h3 id="二、安装TypeScript编译工具"><a href="#二、安装TypeScript编译工具" class="headerlink" title="二、安装TypeScript编译工具"></a>二、安装TypeScript编译工具</h3><p>安装好Node.js后，打开cmd窗口，输入以下命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g typescript</span><br></pre></td></tr></table></figure><p>使用npm包管理工具下载TypeScript包并在全局环境下安装，安装成功后就可以通过 tsc 命令编译TypeScript源码。</p><p>可以通过 tsc -v 命令查看当前TypeScript版本。当前最新版本是：1.8</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-837d58d98ecf8d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><h1 id="第三部分、使用Visual-Studio-Code进行开发"><a href="#第三部分、使用Visual-Studio-Code进行开发" class="headerlink" title="第三部分、使用Visual Studio Code进行开发"></a>第三部分、使用Visual Studio Code进行开发</h1><p>以下目录结构是一个简单的Demo的结构</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-df2f9c7324c1fbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><p>主要包括但不限于以下几个目录和文件</p><p>/ts：TypeScript源码文件存放的文件夹</p><p>/js：编译之后生成的JavaScript文件存放的文件夹</p><p>tsconfig.json：TypeScript编译配置文件</p><p>另外.vscode是VS Code开发工具特有的文件夹，主要用来存放调试时需要用到的配置文件。</p><h3 id="一、tsconfig-json"><a href="#一、tsconfig-json" class="headerlink" title="一、tsconfig.json"></a>一、tsconfig.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line"> <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line"> <span class="attr">"noImplicitAny"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line"> <span class="attr">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">"sourceMap"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">"outDir"</span>: <span class="string">"js"</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"include"</span>:[</span><br><span class="line"> <span class="string">"ts"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">"exclude"</span>: [</span><br><span class="line"> <span class="string">"js"</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个重要的属性需要解释一下：</p><ul><li><ul><li><p>target：编译之后生成的JavaScript文件需要遵循的标准。有三个候选项：es3、es5、es2015。</p></li><li><p>noImplicitAny：为false时，如果编译器无法根据变量的使用来判断类型时，将用any类型代替。为true时，将进行强类型检查，无法推断类型时，提示错误。</p></li><li><p>module：遵循的JavaScript模块规范。主要的候选项有：commonjs、AMD和es2015。为了后面与node.js保持一致，我们这里选用commonjs。</p></li><li><p>removeComments：编译生成的JavaScript文件是否移除注释。</p></li><li><p>sourceMap：编译时是否生成对应的source map文件。这个文件主要用于前端调试。当前端js文件被压缩引用后，出错时可借助同名的source map文件查找源文件中错误位置。</p></li><li><p>outDir：编译输出JavaScript文件存放的文件夹。</p></li><li><p>include、exclude：编译时需要包含/剔除的文件夹。</p></li></ul></li></ul><h3 id="二、添加Demo源文件"><a href="#二、添加Demo源文件" class="headerlink" title="二、添加Demo源文件"></a>二、添加Demo源文件</h3><p>在ts文件夹添加 app.ts 和 demo.ts 两个源文件，目录结构和源文件内容如下</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-3a53c55f602fa6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><h3 id="三、配置编译和调试文件"><a href="#三、配置编译和调试文件" class="headerlink" title="三、配置编译和调试文件"></a>三、配置编译和调试文件</h3><p>在.vscode里添加tasks.json文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line"> <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line"> <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line"> <span class="string">"command"</span>: <span class="string">"tsc"</span>,</span><br><span class="line"> <span class="string">"isShellCommand"</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="string">"args"</span>: [<span class="string">"-p"</span>, <span class="string">"."</span>],</span><br><span class="line"> <span class="string">"showOutput"</span>: <span class="string">"always"</span>,</span><br><span class="line"> <span class="string">"problemMatcher"</span>: <span class="string">"<span class="variable">$tsc</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到调试模式，点击配置按钮，选择Node.js环境。因为接下来的Demo演示都将在Node.js环境下进行。</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-c318acad2663054d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><p>修改生成的launch.json文件内容，指定启动入口文件的路径</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line"> <span class="string">"configurations"</span>: [</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="string">"name"</span>: <span class="string">"启动"</span>,</span><br><span class="line"> <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line"> <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line"> <span class="string">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/js/app.js"</span>,</span><br><span class="line"> <span class="string">"stopOnEntry"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"args"</span>: [],</span><br><span class="line"> <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line"> <span class="string">"preLaunchTask"</span>: null,</span><br><span class="line"> <span class="string">"runtimeExecutable"</span>: null,</span><br><span class="line"> <span class="string">"runtimeArgs"</span>: [</span><br><span class="line"> <span class="string">"--nolazy"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"env"</span>: &#123;</span><br><span class="line"> <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"sourceMaps"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"outDir"</span>: null</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> // ......</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> // ......</span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置完成后，使用 Ctrl+Shift+B 启动编译，如果VS Code的OUTPUT窗口没有任何异常信息显示，则表示编译成功。在js文件夹里将会生成编译后的JavaScript文件</p><p>demo.js</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Demo = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line">Demo.prototype.sum = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> Demo;</span><br><span class="line">&#125;());</span><br><span class="line">exports.Demo = Demo;</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> demo_1 = <span class="built_in">require</span>(<span class="string">'./models/demo'</span>);</span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> demo_1.Demo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(demo.sum());</span><br></pre></td></tr></table></figure><p>对比TypeScript源码文件和生成之后的JavaScript文件，结构发生了较大变化。</p><p>启动调试，查看调试控制台，输出了正确的计算结果：3</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-48cba41f3392aadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><h1 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h1><p>当前非常流行的JavaScript模块规范主要遵循以下两种：</p><ul><li><ul><li><p>CommonJS：同步模式加载模块，主要应用在服务端。Node.js模块化就遵循此规范。使用方式： require(‘模块名’) 。</p></li><li><p>AMD：异步模式加载模块，主要应用在浏览器端。RequireJS遵循此标准。使用方式： define([‘模块名1’, …], function(‘模块参数1’, ….) { })</p></li></ul></li></ul></li></ul><h2 id="创建第一个TypeScript文件"><a href="#创建第一个TypeScript文件" class="headerlink" title="创建第一个TypeScript文件"></a>创建第一个TypeScript文件</h2><ul><li>新建一个目录，在该目录下新建一个文件HelloWorld.ts</li><li>打开文件在文件内输入如下内容，涉及部分ts的语法就不讲了：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span> = <span class="string">"Hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"constructor==========&gt;&gt;&gt;"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> testFun():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"testFun===========&gt;&gt;&gt;"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCallFun</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="keyword">new</span> Test();</span><br><span class="line">    t.testFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译ts文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">tsc HelloWorld.ts</span></span><br></pre></td></tr></table></figure><ul><li>这样就将ts文件编译成了js文件，内容如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Test = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"constructor==========&gt;&gt;&gt;"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    Test.prototype.testFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"testFun===========&gt;&gt;&gt;"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Test;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCallFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">new</span> Test();</span><br><span class="line">    t.testFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里将这个js文件放到html页面上进行测试，控制台输出如下：</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span>==========&gt;&gt;&gt;<span class="title">Hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">testFun</span>===========&gt;&gt;&gt;<span class="title">Hello</span> <span class="title">world</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这样一套完整的工作流就完成了，生成的js文件可以用在各种项目中，Egret项目、cocos项目或者Web项目都可以。通过这种方式可以积累自己的类库，方便做项目时快速开发。</p></blockquote><h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><ul><li>如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。</li><li>在执行tsc时，编译器会在当前目录向父级目录逐级查找tsconfig.json文件，也可以使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录</li><li>例子:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"system"</span>,</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"preserveConstEnums"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"outFile"</span>: <span class="string">"../built/ituuzx/itz.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"include"</span>: [</span><br><span class="line">        <span class="string">"**/*.ts"</span>   //include是指编译包含的文件或目录，这是配置的是包括子目录下的所有ts文件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/10/TypeScript%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>微信小游戏的Adapter适配层</title>
      <link>http://yoursite.com/2018/04/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/</link>
      <guid>http://yoursite.com/2018/04/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/</guid>
      <pubDate>Mon, 09 Apr 2018 18:36:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;为什么要用Adapter&quot;&gt;&lt;a href=&quot;#为什么要用Adapter&quot; class=&quot;headerlink&quot; title=&quot;为什么要用Adapter&quot;&gt;&lt;/a&gt;为什么要用Adapter&lt;/h3&gt;&lt;p&gt;因为小游戏的运行环境在IOS上是javaScriptCore,在安卓上是V8，都没有BOM和DOM的运行环境，没有全局的document和window对象。因此如果直接用DOM API来创建Canvas和Image等元素的时候，会引发错误。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="为什么要用Adapter"><a href="#为什么要用Adapter" class="headerlink" title="为什么要用Adapter"></a>为什么要用Adapter</h3><p>因为小游戏的运行环境在IOS上是javaScriptCore,在安卓上是V8，都没有BOM和DOM的运行环境，没有全局的document和window对象。因此如果直接用DOM API来创建Canvas和Image等元素的时候，会引发错误。</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas=<span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)   <span class="comment">//出现错误</span></span><br></pre></td></tr></table></figure><p>但是我们可以使用wx.createCanvas和wx.createImage来封装一个document。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">document</span>=&#123;</span><br><span class="line">    createElement:<span class="function"><span class="keyword">function</span>(<span class="params">tagName</span>)</span>&#123;</span><br><span class="line">        tagName = tagName.toLowerCase()</span><br><span class="line">        <span class="keyword">if</span>(tagName===<span class="string">'canvas'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> wx.createCanvas()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tagName=== <span class="string">'image'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> wx.createImage()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了上面的函数之后，我们就可以直接创建元素Canvas和Image了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas=<span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> image=<span class="built_in">document</span>.createImage(<span class="string">'image'</span>)</span><br></pre></td></tr></table></figure><p>同样，如果想实现 new Image() 的方式创建 Image 对象，只须添加如下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">Image</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">wx.createImage()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境"><a href="#Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境" class="headerlink" title="Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境"></a>Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境</h3><p>原因：因为小游戏的宿主环境根本没有提供document和window这两个在浏览器中内置的全局变量，而H5游戏基本上大量地使用到这些DOM和BOM API 。Adapter即在引擎和游戏逻辑代码之间加一层模拟 BOM 和 DOM API 的适配层，我们称之为 Adapter。这层适配层在全局通过 wx API 模拟了引擎会访问到的那部分 window 和 document 对象的属性和方法，使引擎感受不到环境的差异。</p><p><img src="https://developers.weixin.qq.com/minigame/dev/tutorial/images/framework-1.png" alt="img](https://developers.weixin.qq.com/minigame/dev/tutorial/images/open-data/data-flow.png)"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Layaair 第一个“微信小游戏”</title>
      <link>http://yoursite.com/2018/04/09/Layaair-%E7%AC%AC%E4%B8%80%E4%B8%AA%E2%80%9C%E5%B0%8F%E6%B8%B8%E6%88%8F%E2%80%9D/</link>
      <guid>http://yoursite.com/2018/04/09/Layaair-%E7%AC%AC%E4%B8%80%E4%B8%AA%E2%80%9C%E5%B0%8F%E6%B8%B8%E6%88%8F%E2%80%9D/</guid>
      <pubDate>Mon, 09 Apr 2018 14:53:20 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Layabox新建文件&quot;&gt;&lt;a href=&quot;#Layabox新建文件&quot; class=&quot;headerlink&quot; title=&quot;Layabox新建文件&quot;&gt;&lt;/a&gt;Layabox新建文件&lt;/h2&gt;&lt;p&gt;步骤一：选中bin右键单击，然后左键点击“新建文件”，在bin目录下建立一个HelloLaya.js的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3497289-e4c4729d6e4f3b62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Layabox新建文件"><a href="#Layabox新建文件" class="headerlink" title="Layabox新建文件"></a>Layabox新建文件</h2><p>步骤一：选中bin右键单击，然后左键点击“新建文件”，在bin目录下建立一个HelloLaya.js的文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/3497289-e4c4729d6e4f3b62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><p>步骤二：按建步骤一的方式，还在bin目录下，修改index.html的文件，</p><p><img src="https://upload-images.jianshu.io/upload_images/3497289-b1361e775817143f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>步骤三：准备工作完成后，就可以编码了，我们打开bin目录下的HelloLaya.js，开始编写如下代码：</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>点点文字，文字会往下移动：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Laya.MiniAdpter.init();<span class="comment">//初始化引擎</span></span><br><span class="line">Laya.init(<span class="number">600</span>,<span class="number">400</span>); <span class="comment">//初始化，创建一个舞台</span></span><br><span class="line">Laya.stage.bgColor=<span class="string">'#00aaff'</span>; <span class="comment">//修改背景色</span></span><br><span class="line"><span class="keyword">var</span> txt=<span class="keyword">new</span> Laya.Text(); <span class="comment">//创建文字对象</span></span><br><span class="line">txt.text=<span class="string">'带我飞！！'</span>; <span class="comment">//定义文字对象的内容</span></span><br><span class="line">txt.fontSize=<span class="number">35</span>; <span class="comment">//设定文本大小</span></span><br><span class="line">txt.color=<span class="string">'#ff1900'</span>; <span class="comment">//文本颜色</span></span><br><span class="line">txt.x=<span class="number">50</span>; <span class="comment">//文本X位置</span></span><br><span class="line">txt.y=<span class="number">100</span>; <span class="comment">//Y位置</span></span><br><span class="line">Laya.stage.addChild(txt); <span class="comment">//为舞台(stage)添加上你创建的这个小文本</span></span><br><span class="line">txt.on(<span class="string">'click'</span>,<span class="keyword">this</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//点击事件，和JS的on事件一样，写在点它它会撒骄！</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(txt.y&gt;=<span class="number">300</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         txt.text=<span class="string">'我跳！！'</span>;</span><br><span class="line">        txt.y = <span class="number">100</span>; <span class="comment">//坐标回到最初位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         txt.text=<span class="string">'点我！！'</span>;</span><br><span class="line">        txt.y+=<span class="number">20</span>; <span class="comment">//坐标往下移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>步骤四：编码完成后，按F5调试，在弹出的页面里，我们可以看到代码的运行结果，如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/3497289-574f8a8f0d0c48ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/3497289-1fc8d4c1cd5a1fa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>点击发布快捷键，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/3497289-487d245263d70463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/3497289-9540a4fdb1dd6bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h2><p><img src="https://upload-images.jianshu.io/upload_images/3497289-f822d46a1ea35609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/3497289-0c1d75b5c1b45a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击预览，若提示文件超过4M，则删除3D文件，先完成一个超小游戏DEMO，<br>后期补充超过4M的解决方案。<br><img src="https://upload-images.jianshu.io/upload_images/3497289-fa2a50f257707065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>使用微信扫预览生成的二维码，即可看到我们做好的小游戏了~！</p><h2 id="微信小游戏4M本地包的使用"><a href="#微信小游戏4M本地包的使用" class="headerlink" title="微信小游戏4M本地包的使用"></a>微信小游戏4M本地包的使用</h2><p>通常我们开发项目的时候，会直接使用本地路径，比如示例中引用的就是本地路径，</p><blockquote><p>Laya.Texture2D.load(“res/layabox.png”);</p></blockquote><p>如果项目的目录中，全部大小加起来不超过4M的话，只要能找到本地的资源，怎么写也没问题。<br>但是，<br>微信小游戏的本地包有4M的限制，一旦超过这个限制，那就不允许上传，不允许真机预览。<br>所以，我们的项目要是大于4M后，怎么处理呢？<br>要进行资源目录的规划，分为本地加载与网络动态加载，两种模式结合使用。<br>本地加载的规划里，我们除了入口文件和必用的配置文件外，只放一些预加载必用的素材，比如加载进度（Loading）页用到的背景与图形等。总之，就是不能超过4M。<br>Tips：需要提醒注意的是微信小游戏不允许动态加载创建JS，所以，JS必须要放在4M包里，也就是说JS加上基础配置文件必须要小于4M，项目适配时如果超过4M，要进行优化控制。<br>网络动态加载的路径怎么处理呢。在本地加载的load()方法之后使用URL.basePath方法。<br>例如：</p><blockquote><p>material.diffuseTexture = Laya.Texture2D.load(“res/layabox.png”);<br>box.meshRender.material = material;<br>Laya.URL.basePath = “<a href="https://XXXX.com&quot;;//请把XXXX换成自己的真实网址；" target="_blank" rel="noopener">https://XXXX.com&quot;;//请把XXXX换成自己的真实网址；</a><br>//在此之下，再使用load加载资源，都会自动加入URL网址。从网络上动态加载。</p></blockquote><p>使用URL.basePath方法后，再使用load加载本地路径，都会自动加上URL.basePath里的网址。这样就实现了本地与网络加载的结合。<br>这样就结束了吗？并没有！<br>按刚刚的写法，res/layabox.png明明已经上传到微信小游戏的本地目录，但是如果在使用URL.basePath之后，再次加载res/layabox.png并不会从本地加载使用，而是从网络动态加载使用。这并不是我们要的结果。<br>所以，引擎针对使用URL.basePath之后，如何再次使用本地加载，进行了特殊目录和文件的处理，也就是本地包白名单机制。如下例所示：</p><blockquote><p>MiniAdpter.nativefiles =  [<br>  “wxlocal”,<br>  “res/atlas/houzi.atlas”,<br>  “res/atlas/houzi.png”,<br>  “common/tishi.png”,<br>  “common/bg.png”,<br>  “ui.json”,<br>  “newLb/bg031.png”<br>];</p></blockquote><p>只要是MiniAdpter.nativefiles里存在的目录名或文件，引擎会自动将该目录视为本地目录，即便使用了URL.basePath，对于包含在nativefiles白名单内的目录名或文件，都不会从网络动态加载，只会从本地加载。</p><p>本文为原创文章，若转载请注明出处：<a href="https://heijiejie.github.io/" target="_blank" rel="noopener">https://heijiejie.github.io/</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/09/Layaair-%E7%AC%AC%E4%B8%80%E4%B8%AA%E2%80%9C%E5%B0%8F%E6%B8%B8%E6%88%8F%E2%80%9D/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
